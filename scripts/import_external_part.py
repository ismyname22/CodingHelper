#!/usr/bin/env python3
import argparse
import json
import os
from datetime import datetime, timezone
from pathlib import Path
from urllib.parse import urlparse
from urllib.request import urlretrieve

REQUIRED_FIELDS = [
    "source",
    "source_url",
    "license",
    "author",
    "download_url",
    "tags",
    "bounding_box",
]


def load_index(index_path: Path) -> dict:
    if index_path.exists():
        with index_path.open("r", encoding="utf-8") as handle:
            return json.load(handle)
    return {"schema_version": 1, "required_fields": REQUIRED_FIELDS, "items": []}


def validate_metadata(metadata: dict) -> None:
    missing = [field for field in REQUIRED_FIELDS if field not in metadata]
    if missing:
        raise ValueError(f"Missing required metadata fields: {', '.join(missing)}")


def download_asset(download_url: str, downloads_dir: Path) -> Path:
    downloads_dir.mkdir(parents=True, exist_ok=True)
    filename = os.path.basename(urlparse(download_url).path) or "downloaded_asset"
    destination = downloads_dir / filename
    urlretrieve(download_url, destination)
    return destination


def append_license_note(output_doc: Path, metadata: dict) -> None:
    output_doc.parent.mkdir(parents=True, exist_ok=True)
    if not output_doc.exists():
        output_doc.write_text(
            "# External Parts License Notes\n\nThis document is generated by the importer. It lists license notices for downloaded assets.\n",
            encoding="utf-8",
        )
    note_lines = [
        "",
        f"## {metadata['source']}",
        f"- Author: {metadata['author']}",
        f"- Source URL: {metadata['source_url']}",
        f"- Download URL: {metadata['download_url']}",
        f"- License: {metadata['license']}",
    ]
    if metadata.get("tags"):
        note_lines.append(f"- Tags: {', '.join(metadata['tags'])}")
    if metadata.get("bounding_box"):
        note_lines.append(f"- Bounding Box: {metadata['bounding_box']}")
    output_doc.write_text(
        output_doc.read_text(encoding="utf-8") + "\n".join(note_lines) + "\n",
        encoding="utf-8",
    )


def main() -> None:
    parser = argparse.ArgumentParser(description="Import external part metadata and asset.")
    parser.add_argument("--metadata", required=True, help="Path to JSON metadata file.")
    parser.add_argument(
        "--index",
        default="external_parts/index.json",
        help="Path to external parts index.json.",
    )
    parser.add_argument(
        "--output-doc",
        default="external_parts/output.md",
        help="Path to license output documentation.",
    )
    parser.add_argument(
        "--downloads-dir",
        default="external_parts/downloads",
        help="Directory where downloaded assets are stored.",
    )
    args = parser.parse_args()

    metadata_path = Path(args.metadata)
    index_path = Path(args.index)
    output_doc = Path(args.output_doc)
    downloads_dir = Path(args.downloads_dir)

    with metadata_path.open("r", encoding="utf-8") as handle:
        metadata = json.load(handle)

    validate_metadata(metadata)

    asset_path = download_asset(metadata["download_url"], downloads_dir)

    index_data = load_index(index_path)
    index_data.setdefault("required_fields", REQUIRED_FIELDS)

    entry = {
        **metadata,
        "stored_path": str(asset_path),
        "downloaded_at": datetime.now(timezone.utc).isoformat(),
    }
    index_data.setdefault("items", []).append(entry)

    index_path.parent.mkdir(parents=True, exist_ok=True)
    with index_path.open("w", encoding="utf-8") as handle:
        json.dump(index_data, handle, indent=2, ensure_ascii=False)
        handle.write("\n")

    append_license_note(output_doc, metadata)


if __name__ == "__main__":
    main()
